\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{parskip}

\setlength{\parskip}{10pt}
% Linespread command allows you to change line spacing for the entire document
\linespread{1.18}

% Tweak page margins
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}

\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\usepackage{natbib}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{fancyhdr}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\Hrule}{\rule{\linewidth}{0.3mm}}

% Project specific macros
\newcommand{\graphite}{GRAPHITE\xspace}
\newcommand{\wave}{WAVE\xspace}

% School specific macros
\newcommand{\schoolShort}{Stanford\xspace}
\newcommand{\school}{Stanford University\xspace}
\newcommand{\schoolLong}{Stanford University MSCS\xspace}

\newcommand{\profOne}{Prof. Ryan Huang\xspace}
\newcommand{\profTwo}{Prof. Xiaonan Huang\xspace}
\newcommand{\profThree}{Prof. Yutong Ban\xspace}

% Creates header for each page
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\header\hskip\linepagesep\vfootline\thepage}
\newskip\linepagesep \linepagesep 5pt\relax
\def\vfootline{%
    \begingroup
    	\rule[-10pt]{0.75pt}{25pt}
    \endgroup
}
\def\header{%
	\begin{minipage}[]{120pt}
		\hfill Yuchen You
    	\par \hfill 				% Formatting boilerplate
    	MSCS, Fall 2026 			% Area, Program, Cycle, Year
    \end{minipage}
}
\fancyhead[RE,LO]{Statement of Purpose | \schoolLong}
\renewcommand\headrulewidth{0pt}

\begin{document}

\noindent\textbf{Motivation and Goals.}
I am applying to the Stanford MS in Computer Science to deepen my preparation in \textbf{computer systems and networking} and to engage in research-oriented, project-heavy work on \textbf{reliable and efficient large-scale computing platforms}. In the long term, I see myself in a \textbf{research-oriented role}---either in an industrial lab or, potentially, through a later PhD program---helping design operating systems and distributed services that remain \textbf{observable, predictable, and dependable} as they scale. The Stanford MSCS is, for me, not a detour from research but a way to systematically strengthen my foundations through \textbf{advanced coursework} and \textbf{project-based learning}, while participating in a systems and AI ecosystem that will let me refine and test my ideas across a range of real-world workloads.

\noindent\textbf{Academic Preparation and Collaboration.}
As a dual-degree student in \textbf{Mechanical Engineering} at Shanghai Jiao Tong University and \textbf{Computer Science} at the University of Michigan, I have built a broad yet rigorous foundation for graduate study in \textbf{systems}. Core courses in data structures and algorithms, operating systems, computer networks, and machine learning, together with labs and project-based classes, trained me to reason about \textbf{performance, correctness, and scalability} while writing substantial amounts of code. At the same time, my mechanical and robotics background keeps me grounded in \textbf{physical constraints} and \textbf{real-world failure modes} instead of purely idealized models.

This combination has also shaped how I work with others. In team projects and as a teaching assistant for an introductory software engineering course, I have led small design discussions, helped classmates debug tricky concurrency and networking bugs, and coordinated milestones under tight deadlines. These experiences taught me to communicate technical trade-offs clearly, to support teammates with different backgrounds, and to take ownership of both the design and the engineering-quality details of a system. I expect these habits to be essential in Stanford's project-oriented MS curriculum.

\noindent\textbf{Embedded and Soft Robotics Foundations.}
My earliest, concrete exposure to \textbf{reliability} came from \textbf{embedded systems and soft robotics}. On a university robotics team, I worked on autonomous sentry robots for competition, helping to design real-time control firmware, \textbf{sensor fusion} logic, and communication over buses such as CAN and I\textsuperscript{2}C. In a related project on an origami-inspired soft robotic arm, I contributed to the control stack and experimental evaluation of a modular, compliant manipulator, eventually co-presenting our results as a spotlight talk and \textbf{best poster award at ICRA 2025 workshop}\cite{you2025origami}.

What stayed with me from these projects was less the hardware itself than the realization that the limiting factor was often the \textbf{data path} rather than the controller in isolation. Sensors were noisy or delayed, actuators did not always respond as modeled, and the system could drift into unsafe regimes without any single, obvious failure. To keep our robots usable, I helped design simple metrics and health checks, and introduced fallbacks to redundant signals or predefined \textbf{degraded-but-safe modes} so that behavior remained stable even when parts of the stack misbehaved. Thinking this way---in terms of \textbf{observability, fault containment, and graceful degradation}---gradually shifted my attention from individual controllers to the larger systems that surround them, and motivated me to study how similar issues appear in \textbf{software infrastructure} such as distributed services and large-scale computing platforms.

\noindent\textbf{Systems Research and Large-Scale Infrastructure.}
With this mindset, I transitioned into \textbf{systems research} in UMich's \textbf{OrderLab}, advised by \textbf{Prof.~Ryan Huang}, to work on improving the operation of \textbf{distributed services} under overload and fluctuating network conditions. My primary role has been to design and implement an \textbf{end-to-end experimental platform}: a closed-loop control plane that ingests telemetry, applies policy-driven traffic shaping, and exposes a library of \textbf{safe, parameterized mitigation actions} such as throttling, rerouting, and I/O limiting. On top of this substrate, I built a dedicated load generator that drives multi-stage traffic patterns and a baseline controller using threshold-based rules so that we can quantify recovery behavior in terms of throughput and tail latency.

More recently, I extended this framework with a \textbf{learning-based policy module} that periodically summarizes system logs and metrics and proposes sequences of mitigations through a narrow, rate-limited interface. Simple overloads can often be handled by a carefully tuned static controller; in more complex, multi-symptom scenarios, the adaptive policy sometimes discovers less obvious combinations of actions that speed up recovery. Designing these experiments forced me to be explicit about what constitutes “healthy” system behavior, how to compare different control strategies fairly, and how to keep automated mitigation \textbf{safe and understandable}.

In parallel, I explored \textbf{GPU runtime support} for ML inference in the \textbf{Advanced Operating System} course project that grew into an independent study. With two collaborators, I co-designed and implemented a prototype runtime that presents a single, high-level inference API but internally selects among several CUDA execution strategies---such as eager submission, batched execution, and persistent workers---based on workload characteristics. We constructed microbenchmarks that emulate dynamic batching and sparse activation patterns and compared each execution path. Profiling revealed that the fastest configuration varied significantly with request size and concurrency, and that a carefully chosen strategy could substantially reduce latency for dynamic workloads. This project improved my understanding of how \textbf{systems techniques and ML workloads} interact, from kernel launch overheads to queuing effects at the service level.

\noindent\textbf{Research Interests and Stanford Fit.}
These experiences shape my interests at the intersection of \textbf{operating systems, distributed systems, and the infrastructure that supports modern data-intensive and ML applications}. I am particularly drawn to \textbf{reliability and efficiency} challenges that arise when systems grow more complex: components may behave inconsistently without crashing, telemetry is noisy and sometimes misleading, and performance problems manifest as subtle shifts in tail latency or throughput rather than clean failures. More broadly, I want to explore how the systems stack that underpins today's applications---from coordination and storage to networking and runtime support---can be made more \textbf{observable, diagnosable, and controllable} in production.

At Stanford, I hope to turn these interests into a more \textbf{principled and broadly applicable} skill set. The MSCS curriculum's strength in \textbf{computer systems and networking}---with rigorous core courses, research-oriented project classes, and offerings that connect systems with machine learning and data-intensive computing---aligns closely with both my preparation and my goals. What attracts me most, however, is the \textbf{research culture}: the close interaction between graduate courses and cutting-edge projects, the expectation that students read and question recent work, and the informal opportunities to learn from peers through seminars, reading groups, and lab collaborations. Classic Stanford systems research on operating systems, networking, and storage has already shaped how I think about \textbf{abstractions, interfaces, and hardware--software co-design}, and I am eager to study in the environment that produced these ideas.

Through \textbf{project-based courses}, independent study, and exposure to ongoing systems and infrastructure efforts, I hope to deepen my understanding of large-scale systems while contributing to more robust platforms in practice. Looking ahead, I aim to pursue a \textbf{career building and studying large-scale systems}, whether in an industrial research lab or through further graduate study after the MS. In the near term, I view the Stanford MSCS as a crucial stage of training and am eager to grow into someone who can design, evaluate, and deploy the next generation of reliable and efficient computing infrastructure.

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}

% That's All Folks.

% Best of luck, you got this! :)